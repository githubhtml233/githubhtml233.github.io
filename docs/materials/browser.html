<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器的基本工作原理 | 路一的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="这是我的第一个 VuePress 文档网站">
    
    <link rel="preload" href="/assets/css/0.styles.a1a5d9b1.css" as="style"><link rel="preload" href="/assets/js/app.7eba2423.js" as="script"><link rel="preload" href="/assets/js/2.b95ab0d4.js" as="script"><link rel="preload" href="/assets/js/1.199773d7.js" as="script"><link rel="preload" href="/assets/js/24.a967cdbe.js" as="script"><link rel="prefetch" href="/assets/js/10.612c4c68.js"><link rel="prefetch" href="/assets/js/11.fb29814a.js"><link rel="prefetch" href="/assets/js/12.1f7fa419.js"><link rel="prefetch" href="/assets/js/13.664b4e1f.js"><link rel="prefetch" href="/assets/js/14.fbd642a5.js"><link rel="prefetch" href="/assets/js/15.553d0dc9.js"><link rel="prefetch" href="/assets/js/16.b9da07d3.js"><link rel="prefetch" href="/assets/js/17.d28cd808.js"><link rel="prefetch" href="/assets/js/18.5adb74f5.js"><link rel="prefetch" href="/assets/js/19.fbf09d3f.js"><link rel="prefetch" href="/assets/js/20.89c1d955.js"><link rel="prefetch" href="/assets/js/21.1ad0ca31.js"><link rel="prefetch" href="/assets/js/22.2d15689e.js"><link rel="prefetch" href="/assets/js/23.0e87d64e.js"><link rel="prefetch" href="/assets/js/25.6f57a836.js"><link rel="prefetch" href="/assets/js/26.3c125277.js"><link rel="prefetch" href="/assets/js/27.97985f07.js"><link rel="prefetch" href="/assets/js/28.62d291a0.js"><link rel="prefetch" href="/assets/js/3.e08a0bbc.js"><link rel="prefetch" href="/assets/js/4.59d158e9.js"><link rel="prefetch" href="/assets/js/5.55af9590.js"><link rel="prefetch" href="/assets/js/6.5d247747.js"><link rel="prefetch" href="/assets/js/7.baaa9855.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.77260563.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a1a5d9b1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/blog.png" alt="路一的博客" class="logo"> <span class="site-name can-hide">路一的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/materials/" class="nav-link router-link-active">
  上下求索
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/materials/" class="nav-link router-link-active">
  上下求索
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>上下求索</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/materials/" aria-current="page" class="sidebar-link">指南</a></li><li><a href="/materials/js.html" class="sidebar-link">JavaScript</a></li><li><a href="/materials/browser.html" aria-current="page" class="active sidebar-link">浏览器的基本工作原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/materials/browser.html#浏览器渲染过程" class="sidebar-link">浏览器渲染过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/materials/browser.html#处理-html" class="sidebar-link">处理 HTML</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#处理-css" class="sidebar-link">处理 CSS</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#构建渲染树" class="sidebar-link">构建渲染树</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#布局-重排" class="sidebar-link">布局（重排）</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#绘制-重绘" class="sidebar-link">绘制（重绘）</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#增量更新" class="sidebar-link">增量更新</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#优化技巧" class="sidebar-link">优化技巧</a></li></ul></li><li class="sidebar-sub-header"><a href="/materials/browser.html#浏览器有哪些进程" class="sidebar-link">浏览器有哪些进程</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#渲染进程的作用" class="sidebar-link">渲染进程的作用</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#渲染进程中的异步-http-请求线程和网络进程有什么区别" class="sidebar-link">渲染进程中的异步 HTTP 请求线程和网络进程有什么区别？</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#浏览器的垃圾回收机制" class="sidebar-link">浏览器的垃圾回收机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/materials/browser.html#标记-清除算法" class="sidebar-link">标记-清除算法</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#分代收集算法" class="sidebar-link">分代收集算法</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#增量标记" class="sidebar-link">增量标记</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#三色标记算法" class="sidebar-link">三色标记算法</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#v8-引擎中的垃圾回收" class="sidebar-link">V8 引擎中的垃圾回收</a></li><li class="sidebar-sub-header"><a href="/materials/browser.html#javascript-内存管理最佳实践" class="sidebar-link">JavaScript 内存管理最佳实践</a></li></ul></li></ul></li><li><a href="/materials/http.html" class="sidebar-link">HTTP</a></li><li><a href="/materials/html.html" class="sidebar-link">HTML</a></li><li><a href="/materials/css.html" class="sidebar-link">CSS</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器的基本工作原理"><a href="#浏览器的基本工作原理" class="header-anchor">#</a> 浏览器的基本工作原理</h1> <h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="header-anchor">#</a> 浏览器渲染过程</h2> <p>首先我们来简单了解下浏览器渲染过程，这个过程一般包含以下步骤：</p> <ol><li>处理 HTML：浏览器接收到 HTML 文档后，开始解析 HTML 标签，生成 DOM 树（Document Object Model Tree）。</li> <li>处理 CSS： 解析 CSS 文件和内嵌的样式，生成 CSSOM 树（CSS Object Model Tree）。</li> <li>构建渲染树：将 DOM 和 CSSOM 树结合起来，生成渲染树（Render Tree）。渲染树包含了需要显示在屏幕上的所有结点。</li> <li>布局（重排）：浏览器计算渲染树中每个节点的位置和大小。</li> <li>绘制（重绘）：将渲染树中的每个节点绘制到屏幕上。</li></ol> <p>接着我们对每一个步骤进行更为详细地讲解：</p> <h3 id="处理-html"><a href="#处理-html" class="header-anchor">#</a> 处理 HTML</h3> <p>当浏览器接收到 HTML 文档后，会逐行解析 HTML 标签，生成 DOM 树。DOM 树是一种树状结构，表示 HTML 文档的结构。</p> <h4 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h4> <h5 id="html-文档"><a href="#html-文档" class="header-anchor">#</a> HTML 文档</h5> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>container<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Hello, World!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>This is a simple example.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h5 id="生成的-dom-树"><a href="#生成的-dom-树" class="header-anchor">#</a> 生成的 DOM 树</h5> <div class="language-markdown extra-class"><pre class="language-markdown"><code><span class="token list punctuation">-</span> html
  <span class="token list punctuation">-</span> head
    <span class="token list punctuation">-</span> title
      <span class="token list punctuation">-</span> &quot;Example&quot;
  <span class="token list punctuation">-</span> body
    <span class="token list punctuation">-</span> div#container
      <span class="token list punctuation">-</span> h1
        <span class="token list punctuation">-</span> &quot;Hello, World!&quot;
      <span class="token list punctuation">-</span> p
        <span class="token list punctuation">-</span> &quot;This is a simple example.&quot;
</code></pre></div><h3 id="处理-css"><a href="#处理-css" class="header-anchor">#</a> 处理 CSS</h3> <p>浏览器解析 CSS 样式和内嵌样式，生成 CSSOM 树。CSSOM 树描述了文档的样式规则。</p> <h4 id="例子-2"><a href="#例子-2" class="header-anchor">#</a> 例子</h4> <h5 id="css-样式"><a href="#css-样式" class="header-anchor">#</a> CSS 样式</h5> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">body</span> <span class="token punctuation">{</span>
  <span class="token property">font-family</span><span class="token punctuation">:</span> Arial<span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">#container</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 80%<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">h1</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">p</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="生成的-cssom-树"><a href="#生成的-cssom-树" class="header-anchor">#</a> 生成的 CSSOM 树</h5> <div class="language-markdown extra-class"><pre class="language-markdown"><code><span class="token list punctuation">-</span> body
  <span class="token list punctuation">-</span> font-family: Arial, sans-serif
<span class="token list punctuation">-</span> #container
  <span class="token list punctuation">-</span> width: 80%
  <span class="token list punctuation">-</span> margin: 0 auto
<span class="token list punctuation">-</span> h1
  <span class="token list punctuation">-</span> color: blue
<span class="token list punctuation">-</span> p
  <span class="token list punctuation">-</span> color: green
</code></pre></div><h3 id="构建渲染树"><a href="#构建渲染树" class="header-anchor">#</a> 构建渲染树</h3> <p>浏览器将 DOM 树和 CSSOM 树结合起来，生成渲染树。渲染树包含了需要显示在屏幕上的所有节点。</p> <h4 id="例子-3"><a href="#例子-3" class="header-anchor">#</a> 例子</h4> <p>渲染树中的每个节点都包含了需要绘制的内容和样式信息：</p> <div class="language-markdown extra-class"><pre class="language-markdown"><code><span class="token list punctuation">-</span> RenderRoot
  <span class="token list punctuation">-</span> RenderBlock (body)
    <span class="token list punctuation">-</span> RenderBlock (div#container)
      <span class="token list punctuation">-</span> RenderInline (h1)
        <span class="token list punctuation">-</span> &quot;Hello, World!&quot;
      <span class="token list punctuation">-</span> RenderInline (p)
        <span class="token list punctuation">-</span> &quot;This is a simple example.&quot;
</code></pre></div><p>渲染树省略了那些不可见的元素，比如 <code>&lt;head&gt;</code> 中的内容</p> <h3 id="布局-重排"><a href="#布局-重排" class="header-anchor">#</a> 布局（重排）</h3> <p>浏览器计算渲染树中每个节点的位置和大小。这个过程称为布局或重排。布局从渲染树的根节点开始，根据 CSS 盒模型计算每个节点的位置和尺寸。</p> <h4 id="例子-4"><a href="#例子-4" class="header-anchor">#</a> 例子</h4> <p>假设浏览器窗口宽度为 1000 px，渲染树的布局计算可能如下：
<code>body</code>：宽度1000px，高度根据内容确定
<code>div#container</code>：宽度80%（800px），水平居中（左右各100px的margin）
<code>h1</code>和<code>p</code>：根据内容和样式计算高度和位置</p> <h3 id="绘制-重绘"><a href="#绘制-重绘" class="header-anchor">#</a> 绘制（重绘）</h3> <p>浏览器将渲染树中的每个节点绘制到屏幕上。绘制过程涉及将样式应用到节点上，并调用系统的绘制功能绘制每个像素。</p> <h4 id="例子-5"><a href="#例子-5" class="header-anchor">#</a> 例子</h4> <p>浏览器使用绘制引擎（如Skia或Direct2D）将每个节点的内容绘制到屏幕上：</p> <p>绘制<code>div#container</code>的背景和边框
绘制<code>h</code>1的蓝色文本 “Hello, World!”
绘制<code>p</code>的绿色文本 “This is a simple example.”</p> <h3 id="增量更新"><a href="#增量更新" class="header-anchor">#</a> 增量更新</h3> <p>当页面内容或样式发生变化时，浏览器会进行增量更新。这通常涉及以下几种情况：</p> <ul><li>DOM 变化：添加、删除或修改节点</li> <li>样式变化： 修改 CSS 样式</li> <li>布局变化： 节点的位置或尺寸发生变化</li> <li>重绘： 节点的外观发生变化（如颜色、字体等）</li></ul> <h4 id="例子-6"><a href="#例子-6" class="header-anchor">#</a> 例子</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 修改DOM</span>
<span class="token keyword">let</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> newElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
newElement<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">'This is a new paragraph.'</span><span class="token punctuation">;</span>
container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>newElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 修改样式</span>
container<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">'lightgrey'</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="优化技巧"><a href="#优化技巧" class="header-anchor">#</a> 优化技巧</h3> <ul><li>减少 DOM 操作：尽量减少直接的 DOM 操作，使用文档片段（DocumentFragment）批量操作 DOM</li> <li>减少重排和重绘：避免频繁修改影响布局的属性，使用 CSS 类进行样式修改</li> <li>使用虚拟 DOM：如 React 中的虚拟 DOM 机制，通过差异计算（diffing）最小化实际的 DOM 操作</li></ul> <h4 id="例子-7"><a href="#例子-7" class="header-anchor">#</a> 例子</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 使用文档片段批量添加元素</span>
<span class="token keyword">let</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  newElement<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Paragraph </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  fragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>newElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="浏览器有哪些进程"><a href="#浏览器有哪些进程" class="header-anchor">#</a> 浏览器有哪些进程</h2> <p>一般来说至少有以下四个进程：</p> <ul><li>浏览器进程：整个浏览器的主进程，负责协调、控制其他进程</li> <li>渲染进程（内核进程）：负责渲染页面内容的进程</li> <li>GPU 进程：负责处理浏览器中与图形相关的任务，例如加速页面绘制、处理 CSS 动画、执行 WebGL 操作等。GPU 进程与渲染进程分离，以提高性能</li></ul> <p>渲染进程一般有 5 类线程</p> <ul><li>GUI 渲染线程：负责渲染网页，当页面触发重绘、回流时该线程也会执行</li> <li>JS 引擎线程：该线程是使用 js 引擎处理 JavaScript 脚本程序，解析 JavaScript 脚本，运行代码</li></ul> <blockquote><p>GUI 渲染线程和 JS 引擎线程是互斥的（因为 GUI 渲染线程和 JavaScript 引擎线程都需要访问和操作 DOM，所以做了线程安全处理），当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等待 JS 引擎空闲时再执行。这也是为什么 JS 文件会阻塞页面加载，一般最好放在 HTML 底部引入的原因。</p></blockquote> <ul><li>事件触发线程：负责处理用户输入和触发相应的事件（例如，点击按钮时，事件触发线程会负责处理这个点击事件）。它管理一个事件队列，当相应的事件被触发后，事件触发线程会把该事件添加到事件队列的队尾，等待 JS 引擎的处理。</li> <li>定时器触发线程：负责处理 setTimeout 和 setInterval 等方法设置的定时器，触发相应的回调函数。</li> <li>异步 HTTP 请求线程：XMLHttpRequest 连接后，浏览器会新开一个线程请求，检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待 JS 引擎空闲后执行</li></ul> <blockquote><p>为什么事件触发、定时器触发、异步 HTTP 请求都会有各自的线程处理呢？因为 JS 引擎是单线程的，这些异步任务会阻塞 JS 的执行。所以要单独开启几个线程和主线程并行执行。这些处理异步操作的线程会把所有异步任务放到一个任务队列中，等待 JS 引擎空闲时，再把他们添加到可执行栈中开始执行（事件循环机制）</p></blockquote> <h2 id="渲染进程的作用"><a href="#渲染进程的作用" class="header-anchor">#</a> 渲染进程的作用</h2> <p>除了上面提到的渲染流程，渲染进程的作用还包括：</p> <ol><li>合成：将各个图层按正确的顺序（根据层叠顺序 z-index 和透明度等因素）合成为最终的画面页面，提高绘制性能</li> <li>处理用户输入：监听用户输入事件（鼠标点击、键盘输入等），并触发相应的事件处理程序</li> <li>脚本执行：执行页面中的 JavaScript 脚本，响应用户交互、更新页面内容</li> <li>处理网络请求：处理页面发起的网络请求，包括获取 HTML、CSS、JavaScript 文件等</li> <li>插件管理：如果页面使用了插件，渲染进程会与插件进行交互</li> <li>内存管理：管理渲染进程的内存使用，确保不发生内存泄漏等问题</li> <li>安全性：实施浏览器的安全策略，防止恶意脚本和攻击</li></ol> <h2 id="渲染进程中的异步-http-请求线程和网络进程有什么区别"><a href="#渲染进程中的异步-http-请求线程和网络进程有什么区别" class="header-anchor">#</a> 渲染进程中的异步 HTTP 请求线程和网络进程有什么区别？</h2> <p>渲染进程中的异步 HTTP 请求线程是专门用来处理 JavaScript 层面的异步网络请求的，例如使用 XMLHttpRequest 对象或 Fetch API 。而网络进程就比较全面，它负责处理所有的网络操作，包括页面导航、处理主页面请求、子页面请求、资源加载等。另外他们俩是协同工作的，例如 JS 发起的异步网络请求，要经历 DNS 解析 -&gt; 建立连接 -&gt; 发送请求 -&gt; 接收响应。当 HTTP 异步请求线程处理 JS 代码发起的异步网络请求时，DNS 解析和建立通常在网络进程中执行，HTTP 异步请求线程则发送请求和接收响应。</p> <h2 id="浏览器的垃圾回收机制"><a href="#浏览器的垃圾回收机制" class="header-anchor">#</a> 浏览器的垃圾回收机制</h2> <p>目前的现代浏览器（如 Chrome、Firefox、Safari 等）使用高效的垃圾回收算法来管理 JavaScript 的内存。这些算法主要是标记-清除和分代收集。</p> <h3 id="标记-清除算法"><a href="#标记-清除算法" class="header-anchor">#</a> 标记-清除算法</h3> <h4 id="基本原理"><a href="#基本原理" class="header-anchor">#</a> 基本原理</h4> <ol><li>标记阶段：从根对象（如全局对象和局部变量）开始，递归地遍历所有可以到达的对象，并标记这些对象为活跃状态</li> <li>清除阶段：遍历堆中的所有对象，回收那些没有被标记为活跃状态的对象的内存
这种方法的好处是能够正确处理循环引用问题。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Alice&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Bob&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>friend <span class="token operator">=</span> b<span class="token punctuation">;</span>
b<span class="token punctuation">.</span>friend <span class="token operator">=</span> a<span class="token punctuation">;</span>

<span class="token comment">// 删除引用</span>
a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token comment">// 垃圾回收器会正确回收a和b指向的对象，因为没有任何根对象指向它们</span>
</code></pre></div><p>在上述例子中，尽管 a 和 b 互相引用，但由于没有任何根对象指向它们，因此它们的内存会被正确回收。</p> <h3 id="分代收集算法"><a href="#分代收集算法" class="header-anchor">#</a> 分代收集算法</h3> <p>现代浏览器通常采用分代收集算法，因为它能更高效地处理不同生命周期的对象。分代收集将堆内存分为几代，通常为&quot;年轻代&quot;（Young Generation）和&quot;老年代&quot;（Old Generation）。</p> <h4 id="基本原理-2"><a href="#基本原理-2" class="header-anchor">#</a> 基本原理</h4> <ol><li>年轻代：存放新创建的对象，垃圾回收频率高。大多数新对象很快会变成垃圾（即对象的生命周期短）。</li> <li>老年代：存放生命周期较长的对象。从年轻代晋升的对象会被移到老年代。垃圾回收频率低。
<strong>年轻代回收（Minor GC）</strong></li></ol> <ul><li>当年轻代的内存用尽时，进行一次 Minor GC</li> <li>将仍然活跃的对象移到老年代
<strong>老年代回收（Major GC）</strong></li> <li>当老年代的内存用尽时，进行一次 Major GC</li> <li>对整个堆进行标记-清除和压缩处理</li></ul> <h3 id="增量标记"><a href="#增量标记" class="header-anchor">#</a> 增量标记</h3> <p>为减少垃圾回收带来的停顿时间，现代垃圾回收器使用增量标记技术。增量标记将标记过程分为多个小步骤，与应用程序的执行交替进行，从而减少每次垃圾回收的停顿时间</p> <h3 id="三色标记算法"><a href="#三色标记算法" class="header-anchor">#</a> 三色标记算法</h3> <p>三色标记算法是一种常用的增量标记算法，将对象分为三种颜色：</p> <ol><li>白色：尚未方位的对象</li> <li>灰色：已访问但其引用的对象尚未完全标记的对象</li> <li>黑色：已访问且其引用的对象已全部标记的对象
通过这种方法，垃圾回收期可以在应用程序运行时逐步标记和清除对象，从而减少停顿时间</li></ol> <h3 id="v8-引擎中的垃圾回收"><a href="#v8-引擎中的垃圾回收" class="header-anchor">#</a> V8 引擎中的垃圾回收</h3> <p>V8 是 Google Chrome 和 Node.js 使用的 JavaScript 引擎。V8 的垃圾回收器使用了上述技术并进行了优化：</p> <ul><li>Scavenger：用于年轻代的垃圾回收，采用半空间复制算法。</li> <li>Mark-Sweep-Compact：用于老年代的垃圾回收，采用标记-清除和标记-压缩算法。</li> <li>Incremental Marking：减少垃圾回收停顿时间的增量标记。</li> <li>Concurrent Marking：在后台线程进行标记，进一步减少停顿时间。</li></ul> <h3 id="javascript-内存管理最佳实践"><a href="#javascript-内存管理最佳实践" class="header-anchor">#</a> JavaScript 内存管理最佳实践</h3> <p>尽管 JavaScript 又垃圾自动回收机制，但遵循以下最佳实践可以帮助优化性能并减少内存泄漏：</p> <ul><li>避免全局遍历：全局遍历生命周期长，容易造成内存泄漏</li> <li>清理不再使用的引用：及时将不再使用的对象设为 null，帮助垃圾回收器识别</li> <li>避免闭包中的不必要引用：闭包容易导致内存泄漏，确保不再需要的变量不被闭包引用</li> <li>使用 WeakMap 和 WeakSet：当需要临时存储对象且不影响垃圾回收时，使用 WeakMap 和 WeakSet
<strong>示例</strong></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> largeArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token string">&quot;data&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>largeArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> closure <span class="token operator">=</span> <span class="token function">createClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// closure保持了对largeArray的引用，largeArray不会被垃圾回收</span>
closure <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 现在largeArray可以被垃圾回收</span>
</code></pre></div><p>通过清理对闭包的引用，可以确保 largeArray 被及时回收，避免内存泄漏</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/materials/js.html" class="prev">
        JavaScript
      </a></span> <span class="next"><a href="/materials/http.html">
        HTTP
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7eba2423.js" defer></script><script src="/assets/js/2.b95ab0d4.js" defer></script><script src="/assets/js/1.199773d7.js" defer></script><script src="/assets/js/24.a967cdbe.js" defer></script>
  </body>
</html>
